#include <file.h>

// File

File::File() :
    _handle(INVALID_HANDLE_VALUE)
{    
}

File::File(const String& fileName, FileMode openMode) :
    _handle(INVALID_HANDLE_VALUE)
{
    if (!open(fileName, openMode))
        throw Exception(STR("failed to open file"));
}

File::~File()
{
    close();
}

bool File::isOpen() const
{
    return _handle != INVALID_HANDLE_VALUE;
}

bool File::open(const String& fileName, FileMode openMode)
{
    if (_handle != INVALID_HANDLE_VALUE)
        throw Exception(STR("file already open"));
    
    int mode;
    
#ifdef PLATFORM_WINDOWS
    switch (openMode)
    {
    case FILE_MODE_CREATE_ALWAYS:
        mode = CREATE_ALWAYS;
        break;
    case FILE_MODE_CREATE_NEW:
        mode = CREATE_NEW;
        break;
    case FILE_MODE_OPEN_ALWAYS:
        mode = OPEN_ALWAYS;
        break;
    default:
    case FILE_MODE_OPEN_EXISTING:
        mode = OPEN_EXISTING;
        break;
    case FILE_MODE_TRUNCATE_EXISTING:
        mode = TRUNCATE_EXISTING;
        break;
    }
    
    _handle = CreateFile(reinterpret_cast<const wchar_t*>(fileName.str()), 
        GENERIC_READ | GENERIC_WRITE, 0, NULL, 
        mode, FILE_ATTRIBUTE_NORMAL, NULL);
#else
    switch (openMode)
    {
    case FILE_MODE_CREATE_ALWAYS:
        mode = O_CREAT | O_TRUNC;
        break;
    case FILE_MODE_CREATE_NEW:
        mode = O_CREAT | O_EXCL;
        break;
    case FILE_MODE_OPEN_ALWAYS:
        mode = O_CREAT;
        break;
    default:
    case FILE_MODE_OPEN_EXISTING:
        mode = 0;
        break;
    case FILE_MODE_TRUNCATE_EXISTING:
        mode = O_TRUNC;
        break;
    }
    
    _handle = ::open(fileName.str(), O_RDWR | mode, 
        S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
#endif
    
    return _handle != INVALID_HANDLE_VALUE;
}

void File::close()
{
    if (_handle != INVALID_HANDLE_VALUE)
    {
#ifdef PLATFORM_WINDOWS
        ASSERT(CloseHandle(_handle));
#else
        ASSERT(::close(_handle) == 0);
#endif
        _handle = INVALID_HANDLE_VALUE;
    }        
}

String File::readString()
{
    if (_handle == INVALID_HANDLE_VALUE)
        throw Exception(STR("file not open"));

#ifdef PLATFORM_WINDOWS
    DWORD bytesSize = size(), charsSize = bytesSize / sizeof(char_t), bytesRead;
#else
    ssize_t bytesSize = size(), charsSize = bytesSize / sizeof(char_t), bytesRead;
#endif

    if (bytesSize % sizeof(char_t) != 0)
        throw Exception(STR("file size must be a multiple of char size"));

    Array<char_t> chars(charsSize + 1);

#ifdef PLATFORM_WINDOWS
    if (ReadFile(_handle, chars.values(), bytesSize, &bytesRead, NULL))
#else
    if ((bytesRead = ::read(_handle, chars.values(), bytesSize)) >= 0)
#endif
    {
        if (bytesSize != bytesRead)
            throw Exception(STR("failed to read entire file"));
    }
    else
        throw Exception(STR("failed to read file"));
            
    chars[charsSize] = 0;
    return String::acquire(chars.release());
}

void File::writeString(const String& str, TextEncoding encoding)
{
    ByteArray bytes = read<byte_t>();
    uint16_t* values = reinterpret_cast<uint16_t*>(bytes.values());

    if (bytes.size() >= 2)
    {
        if (*values == 0xfe && *(values + 1) == 0xff)
            encoding = TEXT_ENCODING_UTF16_BE;
        else if (*values == 0xff && *(values + 1) == 0xfe)
            encoding = TEXT_ENCODING_UTF16_LE;
        else
        {
        }
    }
    else
        encoding = TEXT_ENCODING_UTF8;

}

int64_t File::size() const
{
    if (_handle == INVALID_HANDLE_VALUE)
        throw Exception(STR("file not open"));

#ifdef PLATFORM_WINDOWS
    int64_t sz;
    ASSERT(GetFileSizeEx(_handle, reinterpret_cast<LARGE_INTEGER*>(&sz)));
    return sz;
#else
    struct stat st;
    ASSERT(fstat(_handle, &st) == 0);
    return st.st_size;
#endif
}
